<search><entry><title>部署 Spring Boot application 到 local Kubernetes cluster</title><url>https://2ndbrain.cc/posts/2022/07/spring-boot-on-kubernetes/</url><categories><category>技術</category></categories><tags><tag>spring-boot</tag><tag>gradle</tag><tag>docker</tag><tag>kubernetes</tag></tags><content type="html"> 簡單回顧一下之前的這篇建立容器化 Spring Boot 專案文章中，提到如何容器化 Spring Boot application，本篇要延續這個主題，進階到將 application 部署到 local Kubernetes cluster 上。
容器化 Spring Boot application 使用 Spring Initailizr 網站或 Intellij IDEA 內的 Spring Initailizr 創建 Spring Boot application，服務名稱以 moat-api-gateway 為例。
執行以下指令建置 Docker image 到 local 的 Docker daemon
Gradle Maven ./gradlew bootBuildImage ./mvnw spring-boot:build-image 就可以在 Docker Desktop 的 Dashboard 看到剛剛建置的 moat-api-gateway image： 值得注意的是 image 的建立時間是在 42 年前，為了重複建置 image 時能產出相同 hash 的 image id，所以 Buildpacks 的 timestamp 是固定值 1。
上傳 image 到 local Docker Registry 2.0 2 啟動 local Docker Registry 2.0 $ docker run -d -p 5000:5000 --name docker-registry registry:2 將 gradle 建置出來的 image 重新 tag 取名為 localhost:5000/moat-api-gateway:0.0.1-SNAPSHOT $ docker image tag moat-api-gateway:0.0.1-SNAPSHOT localhost:5000/moat-api-gateway:0.0.1-SNAPSHOT 才能上傳 image 到 local Docker Registry 2.0 $ docker push localhost:5000/moat-api-gateway:0.0.1-SNAPSHOT 啟動 Local Kubernetes cluster 在 Docker Desktop Dashboard 的 Preferences，啟用並啟動 Kubernetes 查看 Kubernetes Cluster 資訊
$ kubectl cluster-info Kubernetes control plane is running at https://kubernetes.docker.internal:6443 CoreDNS is running at https://kubernetes.docker.internal:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy To further debug and diagnose cluster problems, use &amp;#39;kubectl cluster-info dump&amp;#39;. $ kubectl get all NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/kubernetes ClusterIP 10.96.0.1 &amp;lt;none&amp;gt; 443/TCP 20d 部署到 local Kubernetes cluster 3 透過 kubectl cli 產出 deployment.yaml 檔 $ kubectl create deployment moat-api-gateway \ --image=localhost:5000/moat-api-gateway:0.0.1-SNAPSHOT \ --dry-run -o=yaml &amp;gt; deployment.yaml $ echo --- &amp;gt;&amp;gt; deployment.yaml $ kubectl create service clusterip moat-api-gateway \ --tcp=8080:8080 --dry-run -o=yaml &amp;gt;&amp;gt; deployment.yaml 執行 deployment.yaml 檔 $ kubectl apply -f deployment.yaml deployment.apps/moat-api-gateway created service/moat-api-gateway created 重複執行 kubectl get all，查看 pod 的狀態為 Running $ kubectl get all NAME READY STATUS RESTARTS AGE pod/moat-api-gateway-5c565c8df4-hpc9q 1/1 Running 0 3m22s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/kubernetes ClusterIP 10.96.0.1 &amp;lt;none&amp;gt; 443/TCP 21d service/moat-api-gateway ClusterIP 10.103.138.110 &amp;lt;none&amp;gt; 8080/TCP 76m NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/moat-api-gateway 1/1 1 1 3m22s NAME DESIRED CURRENT READY AGE replicaset.apps/moat-api-gateway-5c565c8df4 1 1 1 3m22s 透過 SSH tunnel 就能從 http://localhost:8080 連進 Kubernetes $ kubectl port-forward svc/moat-api-gateway 8080:8080 (Optional) 部署 Kubernetes Dashboard 4 預設不會有 Kubernetes Dashboard，要用以下指令部署：
$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.5.0/aio/deploy/recommended.yaml 執行 kubectl proxy 指令後，就能在瀏覽器用 http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ 看到 Dashboard。
$ kubectl proxy Starting to serve on 127.0.0.1:8001 建立並執行具有 admin 權限的使用者的 dashboard-adminuser.yaml 設定檔
apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kubernetes-dashboard --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard $ kubectl apply -f /path/to/dashboard-adminuser.yaml serviceaccount/admin-user created clusterrolebinding.rbac.authorization.k8s.io/admin-user created 執行以下指令產出 Bearer Token，使用此 Token 登入 Kubernetes Dashboard
$ kubectl -n kubernetes-dashboard create token admin-user Spring Boot 2.3.0 buildpack builds image with creation date 40 years ago &amp;#x21a9;&amp;#xfe0e;
Docker Registry &amp;#x21a9;&amp;#xfe0e;
Spring Boot Kubernetes &amp;#x21a9;&amp;#xfe0e;
Deploy and Access the Kubernetes Dashboard &amp;#x21a9;&amp;#xfe0e;</content></entry><entry><title>在 WebStorm 建置 Jest 單元測試</title><url>https://2ndbrain.cc/posts/2021/09/setup-jest/</url><categories><category>技術</category></categories><tags><tag>npm</tag><tag>jest</tag><tag>javascript</tag></tags><content type="html"> 加入 Jest Library WebStorm 預設沒有載入 Jest，所以會無法識別 Jest 語法，
要從 Preferences → Languages &amp;amp; Frameworks → JavaScript → Libraries 加入 Jest Library。
① 點擊 Download ② 加入 Jest Library 用 npm 安裝 Jest npm init npm install jest 設定 Jest Configuration</content></entry><entry><title>解決 ORA-02292 問題</title><url>https://2ndbrain.cc/posts/2021/07/resolve-ora-02292/</url><categories><category>技術</category></categories><tags><tag>oracle-database</tag><tag>sql</tag></tags><content type="html"> 在刪除資料表中的資料，有時會發生 ORA-02292 違反完整性限制條件 (%s.%s) - 發現子項記錄 錯誤， 導致無法將資料刪除，因為想刪除的資料是其他資料表的 Foreign Key。
錯誤代碼: ORA-02292
描述: 違反完整性限制條件 (%s.%s) - 發現子項記錄
原因: 嘗試刪除具有外鍵依賴性的父鍵值。
動作: 首先刪除依賴項，然後刪除父項或禁用約束。
正規刪除 當兩張資料表存在著父子階層關係，而父階層的資料是子階層的資料對照， 所以資料庫不允許先將父階層資料刪除。此時想刪除父階層資料，必須先刪除子階層資料。
取巧刪除 搞不清楚自己在做什麼的話，不要亂用這招。
若因為某些原因就是想直接刪除父階層資料，而不動到子階層資料時，可以使用禁用約束的方式， 先 disable constraint，刪除想刪的資料後，再 enable constraint，範例如下：
alter table {TABLE_NAME} disable constraint {FOREIGN_KEY_NAME} cascade; -- 執行刪除資料 alter table {TABLE_NAME} enable novalidate constraint {FOREIGN_KEY_NAME}; 值得特別注意的是，在 enable constraint 時，若沒有加上 novalidate， 可能會發生 ORA-02298: 無法驗證 (%s.%s) - 未找到父項關鍵字 錯誤， 因為 Oracle 在 enable constraint 時，會檢核原有資料是否符合約束， 加上 novalidate 就可以再度繞過資料庫的檢核。
搞不清楚自己在做什麼的話，不要亂用這招。</content></entry><entry><title>建置 Gulp 前端自動化整合工具</title><url>https://2ndbrain.cc/posts/2021/07/setup-gulp/</url><categories><category>技術</category></categories><tags><tag>yarn</tag><tag>gulp</tag><tag>github-pages</tag><tag>github-actions</tag></tags><content type="html"> 最近幫切版專案建置一整套 CI/CD 自動化流程，以後只要 push 到 main branch 上， 就會自動部署到 GitHub Pages，終於不用自己手動合併到 gh-pages branch 再 push 囉～
安裝 gulp CLI 因為 yarn 1 的執行效能比 npm 2 好，所以就決定用 Homebrew 安裝 yarn 3 來管理套件。
brew install yarn 使用 yarn 安裝 gulp 4。
yarn global add gulp-cli 查看 gulp CLI 是否安裝成功。
gulp -v CLI version: 2.3.0 Local version: Unknown 安裝 gulp 套件 先移動到目標專案內，再初始化專案。
cd path/to/project yarn init 已切版專案為例，初始化後會產生 package.json 檔
{ &amp;#34;name&amp;#34;: &amp;#34;hello-web-layout&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Web layout practices&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;index.js&amp;#34;, &amp;#34;repository&amp;#34;: &amp;#34;https://github.com/{USER_ACCOUNT}/hello-web-layout.git&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;Irene&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;None&amp;#34;, &amp;#34;private&amp;#34;: true } 安裝 gulp 套件。
yarn add gulp --dev 查看 gulp 是否在專案內 (Local) 安裝成功。
gulp -v CLI version: 2.3.0 Local version: 4.0.2 使用編輯器新增 gulpfile.js 檔案，並加入 task 內容如下：
function defaultTask(cb) { // place code for your default task here cb(); } exports.default = defaultTask 成功執行 gulp 指令執行 task。
gulp [00:15:57] Using gulpfile path/to/project/gulpfile.js [00:15:57] Starting &amp;#39;default&amp;#39;... [00:15:57] Finished &amp;#39;default&amp;#39; after 1.64 ms 安裝 gulp 相關和其他套件 安裝以下套件以建立自動化流程。
# 將 gulp 相關套件用 $ 來引入 yarn add gulp-load-plugins --dev # 清除編譯後的檔案 yarn add gulp-clean --dev # 將檔案變更同步到瀏覽器畫面 yarn add browser-sync --dev # 部署到 GitHub Pages yarn add gulp-gh-pages --dev 查看 package.json 檔，自動更新到 devDependencies 中。
&amp;#34;devDependencies&amp;#34;: { &amp;#34;browser-sync&amp;#34;: &amp;#34;^2.27.4&amp;#34;, &amp;#34;gulp&amp;#34;: &amp;#34;^4.0.2&amp;#34;, &amp;#34;gulp-clean&amp;#34;: &amp;#34;^0.4.0&amp;#34;, &amp;#34;gulp-gh-pages&amp;#34;: &amp;#34;^0.5.4&amp;#34;, &amp;#34;gulp-load-plugins&amp;#34;: &amp;#34;^2.0.7&amp;#34; } 編輯 gulpfile.js 檔案，並加入 task 內容如下：
const gulp = require(&amp;#39;gulp&amp;#39;); const $ = require(&amp;#39;gulp-load-plugins&amp;#39;)({lazy: false}); const browserSync = require(&amp;#39;browser-sync&amp;#39;).create(); const staticFiles = [ &amp;#34;path/to/assets/**/*&amp;#34;, ]; const distPath = &amp;#39;./dist&amp;#39;; function clean() { return gulp.src(distPath, { read: false, allowEmpty: true, }) .pipe($.clean()); } function copy() { return gulp.src(staticFiles) .pipe(gulp.dest(distPath)) .pipe( browserSync.reload({ stream: true, }), ); } function synchronize() { browserSync.init({ server: { baseDir: distPath, }, port: 8080, }); } function watch() { gulp.watch(staticFiles, gulp.series(copy)); } function deploy() { return gulp.src(`${distPath}/**/*`) .pipe($.ghPages()); } exports.default = gulp.series(clean, copy, gulp.parallel(synchronize, watch)); exports.clean = clean; exports.build = gulp.series(clean, copy); exports.deploy = deploy; 建置 GitHub Actions 自動部署 編輯 package.json 檔，在 scripts 區塊定義指令。
&amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;gulp build&amp;#34;, &amp;#34;start&amp;#34;: &amp;#34;gulp&amp;#34;, &amp;#34;deploy&amp;#34;: &amp;#34;gulp deploy&amp;#34; }, 以切版專案為例，在 hello-web-layout/.github/workflows/main.yml 加入 GitHub Actions 腳本， 自動建置和部署網頁到 GitHub Pages。
name: github pages on: push: branches: [ main ] workflow_dispatch: jobs: build: name: Build and deploy GitHub Pages runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v2 with: node-version: &amp;#39;14&amp;#39; cache: &amp;#39;yarn&amp;#39; - name: Caching yarn dependencies run: yarn install - name: Build run: yarn build - name: Deploy to GitHub Pages run: |cd ./dist git init git config --local user.name ${YOUR_USER_NAME} git config --local user.email ${YOUR_USER_EMAIL} git remote add origin https://${{secrets.DEPLOY_GITHUB_PAGE_SECRET}}@github.com/${YOUR_USER_NAME}/hello-web-layout.git git checkout -b gh-pages git add --all git commit -m &amp;#34;Deploy to GitHub Pages by GitHub Actions&amp;#34; git push origin gh-pages -f echo 🤘 Deploy to GitHub Pages completed. Home | Yarn - Package Manager &amp;#x21a9;&amp;#xfe0e;
npm &amp;#x21a9;&amp;#xfe0e;
yarn — Homebrew Formulae &amp;#x21a9;&amp;#xfe0e;
gulp.js &amp;#x21a9;&amp;#xfe0e;</content></entry><entry><title>在 Spring Boot 使用 AOP 印日誌</title><url>https://2ndbrain.cc/posts/2021/06/spring-boot-aop-log/</url><categories><category>技術</category></categories><tags><tag>spring-boot</tag><tag>aop</tag></tags><content type="html"> 使用 AOP (Aspect Oriented Programming) 的方式印出日誌，會比在各處程式中寫印日誌來的簡潔， 集中管理印日誌的程式，避免影響閱讀業務邏輯。
建置 Log4j2 參考這篇建置 Log4j2 文章。
加入 Dependency 在 build.gradle 加入 Spring Boot AOP dependencies：spring-boot-starter-aop，
dependencies { implementation &amp;#39;org.springframework.boot:spring-boot-starter-web&amp;#39; implementation &amp;#39;org.springframework.boot:spring-boot-starter-aop&amp;#39; compileOnly &amp;#39;org.projectlombok:lombok:1.18.18&amp;#39; annotationProcessor &amp;#39;org.projectlombok:lombok:1.18.18&amp;#39; testImplementation &amp;#39;org.springframework.boot:spring-boot-starter-test&amp;#39; } 定義 TimeLogAspect 想像各個業務邏輯是縱向的流程，而 AOP 就是將流程橫剖後織入程式，藉此達到關注點分離。 在元件上標註 @Aspect，即可定義為一個切面，注意也要將物件加註 @Component， Spring Boot 框架才得以管理這個元件。
在方法上標註 @Around 指的是在切面的前、後織入程式，參數 ProceedingJoinPoint 是相對於橫切面的縱向資料流， 可以由此參數取得資料流中的方法簽章和傳入參數等資訊。
而 @Pointcut 定義切面的切點，例如，切點可以是有標註自定義的 Annotation， 或是某個 Controller Package 下的所有 method。
以下是定義在所有標註 @TimeLog 或 Controller 的 Aspect 範例，計算執行這些方法需要多少時間， 並將執行時間於方法回傳後印到日誌中。
@Log4j2 @Aspect @Component public class TimeLogAspect { @Around(&amp;#34;logTime() || controller()&amp;#34;) public Object logAround(ProceedingJoinPoint pjp) throws Throwable { long startMillis = System.currentTimeMillis(); Object proceed = pjp.proceed(); long executionTime = System.currentTimeMillis() - startMillis; log.info(String.format(&amp;#34;Completed %s in %d ms&amp;#34;, pjp.getSignature().toShortString(), executionTime)); return proceed; } @Pointcut(&amp;#34;@annotation(cc.secondbrain.demo.annotation.TimeLog)&amp;#34;) public void logTime() { } @Pointcut(&amp;#34;execution(* cc.secondbrain.demo.controller.*.*(..))&amp;#34;) public void controller() { } } 自定義 Annotation @TimeLog 如下，
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface TimeLog { } 使用自定義 Annotation @TimeLog，可以自由地在想要記錄執行時間的方法上註記，但只限於 public 方法。 值得特別注意的是，假如在 Controller 註記 @TimeLog，只會印出一行執行時間的日誌，不會重複印成兩行。
@RestController public class HelloController { @TimeLog @RequestMapping(&amp;#34;/&amp;#34;) public String hello() { return &amp;#34;Hello Spring Boot&amp;#34;; } }</content></entry><entry><title>建置 Log4j2</title><url>https://2ndbrain.cc/posts/2021/06/setup-log4j2/</url><categories><category>技術</category></categories><tags><tag>gradle</tag><tag>lombok</tag><tag>log4j2</tag></tags><content type="html"> Log4j2 是一套執行效能不錯的日誌工具，Lombok 1 將 Log4j2 日誌工具整合其中， Lombok 也讓 Log4j2 使用起來更簡潔。
建置 Log4j2 在 build.gradle 加入 Lombok dependencies，
dependencies { implementation &amp;#39;org.springframework.boot:spring-boot-starter-web&amp;#39; compileOnly &amp;#39;org.projectlombok:lombok:1.18.18&amp;#39; annotationProcessor &amp;#39;org.projectlombok:lombok:1.18.18&amp;#39; testImplementation &amp;#39;org.springframework.boot:spring-boot-starter-test&amp;#39; } 參考 Log4j2 的文件中的 Console Appender 建立 log4j2.xml 設定檔， 其他用途的日誌設定，可以參考文件的 Appenders 章節 2； 客製化調整日誌樣式，可以參考文件的 Pattern Layout 章節 3。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;Configuration&amp;gt; &amp;lt;Appenders&amp;gt; &amp;lt;Console name=&amp;#34;STDOUT&amp;#34; target=&amp;#34;SYSTEM_OUT&amp;#34;&amp;gt; &amp;lt;PatternLayout pattern=&amp;#34;%m%n&amp;#34;/&amp;gt; &amp;lt;/Console&amp;gt; &amp;lt;/Appenders&amp;gt; &amp;lt;Loggers&amp;gt; &amp;lt;Root level=&amp;#34;info&amp;#34;&amp;gt; &amp;lt;AppenderRef ref=&amp;#34;STDOUT&amp;#34;/&amp;gt; &amp;lt;/Root&amp;gt; &amp;lt;/Loggers&amp;gt; &amp;lt;/Configuration&amp;gt; 使用日誌 在要印出日誌的 class 宣告上標注 @Log4j2，就可以用 log 印出不同等級的日誌。
@Log4j2 @RestController public class HelloController { @RequestMapping(&amp;#34;/&amp;#34;) public String hello() { log.info(&amp;#34;hello log4j2&amp;#34;); return &amp;#34;Hello Spring Boot&amp;#34;; } } projectlombok/lombok: Very spicy additions to the Java programming language. &amp;#x21a9;&amp;#xfe0e;
Log4j – Log4j 2 Appenders &amp;#x21a9;&amp;#xfe0e;
Log4j – Log4j 2 Layouts &amp;#x21a9;&amp;#xfe0e;</content></entry><entry><title>設定 cURL Connect Timeout 時間</title><url>https://2ndbrain.cc/posts/2021/06/curl-connect-timeout/</url><categories><category>技術</category></categories><tags><tag>curl</tag></tags><content type="html"> 因為 curl 的預設 Timeout 時間為 5 分鐘1，所以在進行 Timeout 的測試時，要等待很長的時間，
可以透過設定 --connect-timeout 參數，以減少等待時間。
# 設定 Timeout 為 5 秒 curl http://localhost:8080 --connect-timeout 5 curl/connect.h at master · curl/curl · GitHub &amp;#x21a9;&amp;#xfe0e;</content></entry><entry><title>執行 Junit Jupiter 測試的疑難雜症</title><url>https://2ndbrain.cc/posts/2021/05/setup-junit-jupiter/</url><categories><category>技術</category></categories><tags><tag>gradle</tag><tag>junit-jupiter</tag></tags><content type="html"> 以下用 Gradle 6.8.3 為例，列出幾個在執行 Junit Jupiter 測試時的疑難雜症，希望能少點踩雷的時間。
Cannot resolve symbol &amp;lsquo;jupiter&amp;rsquo; 在 build.gradle 加入 junit-jupiter 的 dependency，
dependencies { ... // Use JUnit test framework testImplementation &amp;#39;org.junit.jupiter:junit-jupiter-api:5.3.2&amp;#39; } 發生 PreconditionViolationException 若是在執行測試時，程式拋出 PreconditionViolationException: Cannot create Launcher without at least one TestEngine; consider adding an engine implementation JAR to the classpath，
org.gradle.api.internal.tasks.testing.TestSuiteExecutionException: Could not complete execution for Gradle Test Executor 1. at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:63) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) at com.sun.proxy.$Proxy2.stop(Unknown Source) at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:133) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414) at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) at java.lang.Thread.run(Thread.java:745) Caused by: org.junit.platform.commons.util.PreconditionViolationException: Cannot create Launcher without at least one TestEngine; consider adding an engine implementation JAR to the classpath at org.junit.platform.commons.util.Preconditions.condition(Preconditions.java:295) at org.junit.platform.launcher.core.DefaultLauncher.&amp;lt;init&amp;gt;(DefaultLauncher.java:48) at org.junit.platform.launcher.core.LauncherFactory.create(LauncherFactory.java:105) at org.junit.platform.launcher.core.LauncherFactory.create(LauncherFactory.java:75) at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:97) at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) ... 25 more 在 build.gradle 加入 junit-jupiter-engine 的 dependency，注意是 Runtime 會使用到 Test Engine，
dependencies { ... // Use JUnit test framework testImplementation &amp;#39;org.junit.jupiter:junit-jupiter-api:5.3.2&amp;#39; testRuntimeOnly &amp;#39;org.junit.jupiter:junit-jupiter-engine:5.3.2&amp;#39; } 發生 ClassNotFoundException 若是在執行測試時，程式拋出 ClassNotFoundException: org.junit.platform.engine.support.discovery.SelectorResolver，
org.gradle.api.internal.tasks.testing.TestSuiteExecutionException: Could not complete execution for Gradle Test Executor 6. at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:63) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) at com.sun.proxy.$Proxy2.stop(Unknown Source) at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:133) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:182) at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:164) at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:414) at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64) at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56) at java.lang.Thread.run(Thread.java:745) Caused by: org.junit.platform.commons.JUnitException: TestEngine with ID &amp;#39;junit-jupiter&amp;#39; failed to discover tests at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:111) at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discover(EngineDiscoveryOrchestrator.java:85) at org.junit.platform.launcher.core.DefaultLauncher.discover(DefaultLauncher.java:92) at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:75) at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) ... 25 more Caused by: java.lang.NoClassDefFoundError: org/junit/platform/engine/support/discovery/SelectorResolver at org.junit.jupiter.engine.JupiterTestEngine.discover(JupiterTestEngine.java:69) at org.junit.platform.launcher.core.EngineDiscoveryOrchestrator.discoverEngineRoot(EngineDiscoveryOrchestrator.java:103) ... 32 more Caused by: java.lang.ClassNotFoundException: org.junit.platform.engine.support.discovery.SelectorResolver at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 34 more 在 build.gradle 將 junit-jupiter 和 junit-jupiter-engine 的 dependency，降版至 5.3.x，
dependencies { ... // Use JUnit test framework testImplementation &amp;#39;org.junit.jupiter:junit-jupiter-api:5.3.2&amp;#39; testRuntimeOnly &amp;#39;org.junit.jupiter:junit-jupiter-engine:5.3.2&amp;#39; }</content></entry><entry><title>排程執行 Cucumber 測試</title><url>https://2ndbrain.cc/posts/2021/05/separate-cucumber-test/</url><categories><category>技術</category></categories><tags><tag>gradle</tag><tag>cucumber</tag><tag>github-actions</tag></tags><content type="html"> 何時執行整合測試？ 通常整合測試執行時間比單元測試長很多，也因為整合測試的執行頻率無法像單元測試一樣頻繁，比較適合每日排程執行。 為了在進行開發而頻繁執行測試時，不需要等待整合測試執行，所以特別將整合測試獨立成一個 Source Set，不和單元測試程式放在一起。
另一種方式是將整合測試獨立成一個專案，在 Gradle 設定上應該會比較簡單 XD。 以下說明是針對比較搞剛的 Gradle Source Set 1。
設定 Cucumber Gradle Task 初始化 Gradle 專案
gradle init 在 build.gradle 檔加入 integration Source Set 相關設定
① 新增 integration Source Set
sourceSets { integration { java.srcDir &amp;#34;/src/integration/java&amp;#34; resources.srcDir &amp;#34;/src/integration/resources&amp;#34; } } ② 加入整合測試會用到的 Cucumber Dependency 2
dependencies { ... integrationImplementation &amp;#39;io.cucumber:cucumber-java:6.8.1&amp;#39; } ③ 加入 Configuration 在 Runtime 使用 Cucumber Dependency
configurations { cucumberRuntime.extendsFrom integrationImplementation } ④ 新增 cucumber Task
注意： 以下在執行 io.cucumber.core.cli.Main 所帶入的參數陣列 args 中， 第 4 個參數是指 Cucumber Step Definition 的 Java 程式碼所在的 Package， 而 5 個參數是指 Cucumber Feature 檔的所在路徑
task cucumber() { dependsOn assemble, integrationClasses doLast { javaexec { main = &amp;#34;io.cucumber.core.cli.Main&amp;#34; classpath = configurations.cucumberRuntime + sourceSets.integration.output args = [&amp;#39;--plugin&amp;#39;, &amp;#39;pretty&amp;#39;, &amp;#39;--glue&amp;#39;, &amp;#39;scenario&amp;#39;, &amp;#39;src/integration/resources&amp;#39;] } } } 執行 Gradle Task cucumber 確認 Cucumber 安裝成功
./gradlew cucumber 撰寫 Feature 和 Step Definition 以 RSA 加解密需求為例，
在 src/integration/resources 內的 feature 路徑新增 Cryptosystem.feature 如下 Feature:Encrypt and Decrypt with RSA Scenario:Press button to generate RSA key pair Given Navigate to cryptosystem page When I press button to generate RSA key pair Then I should be able to download key pair zip file src/integration/java 內的 Package scenario 新增對應的 Cryptosystem.java 如下，（未撰寫測試程式） package scenario; import io.cucumber.java.en.Given; import io.cucumber.java.en.Then; import io.cucumber.java.en.When; public class Cryptosystem { @Given(&amp;#34;Navigate to cryptosystem page&amp;#34;) public void navigate_to_cryptosystem_page() { } @When(&amp;#34;I press button to generate RSA key pair&amp;#34;) public void i_press_button_to_generate_rsa_key_pair() { } @Then(&amp;#34;I should be able to download key pair zip file&amp;#34;) public void i_should_be_able_to_download_key_pair_zip_file() { } } 執行 Gradle Task cucumber 確認 Cucumber 測試成功 ./gradlew cucumber GitHub Actions 排程執行整合測試 加入 GitHub Actions 腳本 .github/workflows/cucumber.yml，自動排程執行 Cucumber 測試。
name: Cucumber Daily Test on: schedule: # At 0AM UTC of every day - cron: &amp;#34;0 0 * * *&amp;#34; jobs: build: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 - name: Set up JDK 11 uses: actions/setup-java@v2 with: java-version: &amp;#39;11&amp;#39; distribution: &amp;#39;adopt&amp;#39; - name: Grant execute permission for gradlew run: chmod +x gradlew - name: Run cucumber test run: ./gradlew cucumber Separate Gradle Tasks for Unit and Integration Tests - INSPEERITY - Agile Software Factory &amp;#x21a9;&amp;#xfe0e;
10 Minute Tutorial - Cucumber Documentation &amp;#x21a9;&amp;#xfe0e;</content></entry><entry><title>建立容器化 Spring Boot 專案</title><url>https://2ndbrain.cc/posts/2021/04/spring-boot-docker-image/</url><categories><category>技術</category></categories><tags><tag>spring-boot</tag><tag>gradle</tag><tag>docker</tag></tags><content type="html"> 建立新 Spring Boot 專案 使用 Intellij IDEA 建立新專案，專案資訊如下：
Spring Boot 版本：2.4.5 專案類型：Gradle 語言：Java 11 ① 使用 Intellij IDEA 內的 Spring Initailizr 創建新專案 ② 加入 Spring Web Dependency 增加 HelloController.java 如下：
package cc.secondbrain.demo.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @RequestMapping(&amp;#34;/&amp;#34;) public String hello() { return &amp;#34;Hello Spring Boot&amp;#34;; } } 啟動 Spring Boot 服務，用瀏覽器瀏覽 http://localhost:8080/，就可以看到「Hello Spring Boot」
容器化 Spring Boot 安裝 Docker Desktop 啟動 Docker Desktop Spring Boot 2.3.0 版開始支援 Cloud Native Buildpacks 1， 執行以下指令建置 Docker Image 到 Local 的 Docker daemon ./gradlew bootBuildImage --imageName=springbootdemo 啟動容器化 Spring Boot 服務 docker run -it -p8080:8080 springbootdemo How to Docker with Spring Boot | Okta Developer &amp;#x21a9;&amp;#xfe0e;</content></entry><entry><title>查詢系統資訊指令</title><url>https://2ndbrain.cc/posts/2021/04/system-basic-info/</url><categories><category>技術</category></categories><tags><tag>linux</tag><tag>database</tag></tags><content type="html"> Linux 系統資訊 查看 Linux 版本資訊
cat /etc/os-release 查看 Linux Kernel 版本資訊
uname -r Oracle Database 系統資訊 使用資料庫管理工具 Oracle SQL Devloper 查看 Oracle Database 版本資訊：
Reports → About Your Database → Version Banner
或執行 SQL 查看 Oracle Database 版本資訊
SELECT * FROM v$version;</content></entry><entry><title>202102 演化式設計：測試驅動開發與持續重構 -- 心得</title><url>https://2ndbrain.cc/posts/2021/04/202102-tdd-refactoring/</url><categories><category>日誌</category></categories><tags><tag>tdd</tag><tag>refactoring</tag></tags><content type="html"> 上完 [演化式設計：測試驅動開發與持續重構] 1，課後兩個月補記心得和筆記。
熟練 Tennis Kata TDD 練習，上傳到 Youtube 頻道 了解 Code Smell 和 Refactoring 相關知識 熟練課堂上的 BudgetCalculator TDD 重構練習 專業有價 早在 2018 左右就聽說 91 的課 2，當時看到上課時間居然在半年後，而且一堂課要價超過一萬元，就一直處於觀望狀態而沒有報名課程。 幸好在這期間我看了《刻意練習》後，就一直心心念念想找到利用「刻意練習」模式教學的課程，再加上我開始認同「專業有價」，花錢就能買到別人累積的功力，超級划算。 於是，在剩下最後幾個名額時，趕緊手刀報名，心裡想不管發生什麼事，都不能妨礙我去上課，要是再不做出行動，現在這門課是開課前一年就額滿 ⋯⋯
從了解需求開始 由實作的人去問出需求 用具體的例子談需求，甚至用錯誤的例子誘導對方講出正確的需求 說到討論需求，近日有新的感想，我終於可以察覺出「問出需求」和「擬定做法」是兩回事。 以前很多時候，我只是在覆核 PM 提出的調整可不可行，而沒有去探究背後的需求，現在可以練習再多問『想做出調整的原因？』和問『什麼會想用這個方式調整？』， 這樣才能有足夠的資訊選擇最適當的做法。另外，我發現我很習慣用簡短或沒整理過的描述和其他人討論事情，用具體的例子和其他人溝通是我還需要多練習的課題。
便利貼起手式 拆解會需要的程式碼片段，可使用便利貼或 Mind Map 工具 和團隊成員一起決定命名或 API 規格 以前我都會一邊設計程式一邊敲鍵盤，因為覺得與其花時間在腦袋一直空想，還不如直接就開始寫程式，邊理解需求邊寫程式還邊重構，自以為我真是會敏捷開發， 但是常常發生 A 設計寫到一半覺得不夠好，應該要改成 B 設計，B 設計寫到一半發現有情境沒考慮到，所以一開始才會寫成 A 設計那樣， 改過來又改回去，搞到最後沒時間好好梳理程式架構和流程。
所以二月週末上完課，週一進辦公室，我就乖乖到文具櫃去拿一本便利貼來用，仔細拆解會需要的程式碼片段，再開始敲程式碼， 寫程式有明顯變得比較順，思路也比較周全，反而花比較少時間開發，對於 Task 的完成度更有信心。
安排測試案例，小步重構 測試案例必須是使用情境，命名要描述 Domain，不能出現具體的例子名稱 測試案例從最簡單的案例開始寫，如果要改太多就拆小一點 最簡單的意思是：加最少的程式碼片段，或複製測試案例改最少的程式碼片段。
TDD 只需要列出可以把需要的程式碼片段開發完成即可，不用列出所有案例 我之前以為用排列組合列出所有測試案例，就是最系統化的方式，完全沒想過測試案例的順序是要刻意安排的， 所以一次不會改動太多程式，比較沒有除錯壓力，搭配便利貼起手式一起服用更有效。 先做好全局的思考，這時候再開始用 TDD 的方式寫程式：
Baby Step：一次做少一點，然後該做的有做完（一個完整的使用情境） 紅燈 → 綠燈：無腦通過測試案例 綠燈 → 重構：從刻意產生重複的程式碼演進成 Production Code 設計 重構 Legacy Code Legacy Code 是實務上最常會遇到的情況，通常 Legacy Code 沒有單元測試保護，所以就沒人敢改。 利用單元測試和強大的 IDE 工具 3 自動產生程式碼做重構，安全地跳脫惡性循環：
整理代碼：刪除 comment、調整爛命名、多餘空白行、Temp Variables 整理流程：消除重複、凸顯意圖 不要太早抽方法，會不容易看出重複，可用 Inline Method 回復 Method。
改邏輯要有對應的測試保護 分職責 物件導向（高內聚）：用物件模型模擬真實世界，把資料往物件堆，叫物件做事 Design Pattern（低耦合） 原則上設計心法就是用最簡單的方式滿足使用者情境，並且寫最少的防呆，參數越少越好用。
Keep it Simple, don&amp;rsquo;t overdesign your solution.
結論 [演化式設計：測試驅動開發與持續重構] 是 [針對遺留代碼加入單元測試的藝術] 和 [極速開發] 兩門課的集大成，上完課後仍需要不斷練習和反思，才能持續進步。 原本課前預習就應該要先了解 Code Smell 和 Refactoring 相關知識， 但在上課前我沒有確實做到，現在要補下基本功，也藉此督促自己要熟練課堂上的重構練習。
【演化式設計：測試驅動開發與持續重構】 202102 台北 | In 91 - 點部落 &amp;#x21a9;&amp;#xfe0e;
最好的 TDD 學習資源 - 敏捷開發軍火庫 &amp;#x21a9;&amp;#xfe0e;
JetBrains: Essential tools for software developers and teams &amp;#x21a9;&amp;#xfe0e;</content></entry><entry><title>Hugo 教學 -- 進階篇</title><url>https://2ndbrain.cc/posts/2021/04/get-advanced-hugo/</url><categories><category>技術</category></categories><tags><tag>hugo</tag><tag>godaddy</tag><tag>github-actions</tag><tag>google-analytics</tag><tag>utterances</tag></tags><content type="html"> 本篇利用 Hugo 建立個人化網站，基本應用參考 Hugo 系列文：
Hugo 教學 &amp;ndash; 基礎篇 Hugo 教學 &amp;ndash; 進階篇 Custom Domain 在 GoDaddy 購買屬於自己的網域，例如：2ndbrain.cc 在 Terminal 用指令 dig 查詢個人 GitHub Pages 的 IP dig {YOUR_USER_NAME}.github.io 在 GoDaddy 設定 IP 和 轉址 Domain 在 Repository {YOUR_USER_NAME}.github.io 的 Settings &amp;gt;&amp;gt; Pages 設定 Custom domain 在 Repository {YOUR_USER_NAME}.github.io 的根目錄加入 CNAME 檔案 echo &amp;#39;YOUR_DOMAIN&amp;#39; &amp;gt;&amp;gt; CNAME echo &amp;#39;2ndbrain.cc&amp;#39; &amp;gt;&amp;gt; CNAME GitHub Actions 自動建置和部署 GitHub Pages 在 hugo-site/.github/workflows/main.yml 加入 GitHub Actions 腳本 1，自動建置和部署網頁到 GitHub Pages 2。
name: github pages # Controls when the action will run. on: # Triggers the workflow on push event but only for the main branch push: branches: [ main ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called &amp;#34;build&amp;#34; build: name: Build and deploy GitHub Pages # The type of runner that the job will run on runs-on: ubuntu-18.04 # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: &amp;#39;0.82.0&amp;#39; # extended: true - name: Build run: hugo --minify - name: Deploy run: |cd ./public echo &amp;#39;${YOUR_DOMAIN}&amp;#39; &amp;gt;&amp;gt; CNAME git init git config --local user.name ${YOUR_USER_NAME} git config --local user.email ${YOUR_USER_EMAIL} git status git remote add origin https://${{secrets.DEPLOY_GITHUB_PAGE_SECRET}}@github.com/${YOUR_USER_NAME}/${YOUR_USER_NAME}.github.io.git git checkout -b main git add --all git commit -m &amp;#34;Deploy to GitHub Pages by GitHub Actions&amp;#34; git push origin main -f echo 🤘 Deploy to GitHub Pages completed. Google Analytics 在 Google Analytics 新增資源設定 在 config.toml 加上設定，啟用 Hugo 內建 internal templates 3 googleAnalytics = &amp;#34;G-MEASUREMENT_ID&amp;#34; 在樣式中加入 /layouts/_internal/google_analytics.html gtag.js 檔案 &amp;lt;!-- Global site tag (gtag.js) - Google Analytics --&amp;gt; &amp;lt;script async src=&amp;#34;https://www.googletagmanager.com/gtag/js?id=${G-MEASUREMENT_ID}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(&amp;#39;js&amp;#39;, new Date()); gtag(&amp;#39;config&amp;#39;, &amp;#39;${G-MEASUREMENT_ID}&amp;#39;); &amp;lt;/script&amp;gt; 在網站的每一頁加入 Google Analytics template {{ template &amp;#34;_internal/google_analytics.html&amp;#34; . }} 在 Google Analytics 分析網站流量 utterances 留言系統 在 GitHub 建立一個 Public Repository，例如 utterances-comment 安裝 utterances 到 Repository utterances-comment 利用 utterances 官網產生 template，在樣式中加入 /layouts/_internal/comment.html javascript 檔案 &amp;lt;script src=&amp;#34;https://utteranc.es/client.js&amp;#34; repo=&amp;#34;[ENTER REPO HERE]&amp;#34; issue-term=&amp;#34;pathname&amp;#34; theme=&amp;#34;github-light&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34; async&amp;gt; &amp;lt;/script&amp;gt; 在每篇文章加入 utterances template {{ template &amp;#34;_internal/comment.html&amp;#34; . }} Host on GitHub | Hugo &amp;#x21a9;&amp;#xfe0e;
深入但不淺出，如何用 github actions 自動發佈 gh-pages | by Milk Midi | Medium &amp;#x21a9;&amp;#xfe0e;
Internal Templates | Hugo &amp;#x21a9;&amp;#xfe0e;</content></entry><entry><title>Hugo 教學 -- 基礎篇</title><url>https://2ndbrain.cc/posts/2021/04/get-started-hugo/</url><categories><category>技術</category></categories><tags><tag>github-pages</tag><tag>hugo</tag></tags><content type="html"> 本篇利用 Hugo 從無到有建立個人網站，進階應用參考 Hugo 系列文：
Hugo 教學 &amp;ndash; 基礎篇 Hugo 教學 &amp;ndash; 進階篇 Get Started 1 2 在 GitHub 建立一個 Private Repository hugo-site 管理網站原始碼 在 GitHub 建立一個 Public Repository {YOUR_USER_NAME}.github.io 用來上傳靜態網頁到 GitHub Pages 下載 hugo-site 到 Local git clone https://github.com/{YOUR_USER_NAME}/hugo-site.git 或下載包含 Git Submodule 的 Repository 到 Local
git clone --recursive https://github.com/{YOUR_USER_NAME}/hugo-site.git 使用 Homebrew 安裝 Hugo brew install hugo 使用 Hugo CLI 確認 Hugo 安裝是否成功
hugo version 在放置 hugo-site 的同層路徑（非 hugo-site 資料夾內），使用 Hugo CLI 建立新靜態頁面網站 hugo new site hugo-site 若發生以下錯誤：
Error: /path/to/hugo-site already exists and is not empty. See --force.
加上參數 --force 強制建立網站
hugo new site hugo-site --force 在 themes.gohugo.io 網站樣式，Fork 欲選樣式的 Repository 到自己的 GitHub，以方便調整樣式 以 hugo-theme-next 樣式 3 為例，將樣式專案以 Submodule 形式加入 hugo-site cd hugo-site git submodule add https://github.com/{YOUR_USER_NAME}/hugo-theme-next.git themes/next 根據 ./themes/next/config.toml 的設定調整 ./config.toml 使用 Hugo CLI 建立新文章 hugo new posts/2021/04/get-started-hugo.md 使用 Hugo CLI 在 Local 起 Server，建置並在 http://localhost:1313/ 檢視網站更新 hugo server -D 檢視新文章 http://localhost:1313/posts/2021/04/get-started-hugo/
使用 Hugo CLI 在 hugo-site/public 建製靜態網頁 將 hugo-site/public Push 到 Repository {YOUR_USER_NAME}.github.io 後，在 https://{YOUR_USER_NAME}.github.io/ 檢視網站更新 Hugo 貼身打造個人部落格 :: 第 12 屆 iT 邦幫忙鐵人賽 &amp;#x21a9;&amp;#xfe0e;
Quick Start | Hugo &amp;#x21a9;&amp;#xfe0e;
xtfly/hugo-theme-next: This is a hugo theme forked from hexo-theme-next &amp;#x21a9;&amp;#xfe0e;</content></entry></search>