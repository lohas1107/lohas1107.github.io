"use strict";(self.webpackChunk_2_ndbrain=self.webpackChunk_2_ndbrain||[]).push([[2312],{9344:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var r=i(5893),t=i(1151);const s={},o="64. Minimum Path Sum",l={id:"leetcode/minimum-path-sum",title:"64. Minimum Path Sum",description:"\u21aa LeetCode",source:"@site/docs/leetcode/0064-minimum-path-sum.md",sourceDirName:"leetcode",slug:"/leetcode/minimum-path-sum",permalink:"/docs/leetcode/minimum-path-sum",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:64,frontMatter:{},sidebar:"leetcodeSidebar",previous:{title:"22. Generate Parentheses",permalink:"/docs/leetcode/generate-parentheses"},next:{title:"136. Single Number",permalink:"/docs/leetcode/single-number"}},a={},d=[{value:"Understanding the Problem",id:"understanding-the-problem",level:2},{value:"Input/Output Restrictions",id:"inputoutput-restrictions",level:3},{value:"Corner Cases",id:"corner-cases",level:3},{value:"Algorithmic Solutions",id:"algorithmic-solutions",level:2},{value:"Dynamic Programming",id:"dynamic-programming",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:4},{value:"Space Optimized Dynamic Programming",id:"space-optimized-dynamic-programming",level:3},{value:"Complexity Analysis",id:"complexity-analysis-1",level:4},{value:"In-Place Dynamic Programming",id:"in-place-dynamic-programming",level:3},{value:"Complexity Analysis",id:"complexity-analysis-2",level:4},{value:"Conclusion",id:"conclusion",level:2}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"64-minimum-path-sum",children:"64. Minimum Path Sum"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-path-sum/",children:"\u21aa LeetCode"})}),"\n",(0,r.jsx)(n.p,{children:'We\'ll dissect the "Minimum Path Sum" problem from LeetCode, a classic question that tests your understanding of dynamic programming and grid traversal. This guide will walk you through the problem-solving process, showcasing how to approach, analyze, and solve such problems efficiently.'}),"\n",(0,r.jsx)(n.h2,{id:"understanding-the-problem",children:"Understanding the Problem"}),"\n",(0,r.jsxs)(n.p,{children:["Given a ",(0,r.jsx)(n.code,{children:"m x n"})," grid filled with non-negative numbers, find a path from the top left to the bottom right, which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time."]}),"\n",(0,r.jsx)(n.h3,{id:"inputoutput-restrictions",children:"Input/Output Restrictions"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Input:"})," A 2D array ",(0,r.jsx)(n.code,{children:"grid"})," of size ",(0,r.jsx)(n.code,{children:"m x n"}),", where ",(0,r.jsx)(n.code,{children:"m"})," is the number of rows and ",(0,r.jsx)(n.code,{children:"n"})," is the number of columns. Each element ",(0,r.jsx)(n.code,{children:"grid[i][j]"})," represents the cost of passing through ",(0,r.jsx)(n.code,{children:"(i, j)"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Output:"})," An integer representing the minimum path sum from the top-left corner to the bottom-right corner."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"corner-cases",children:"Corner Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Cell Grid:"})," The grid consists of only one cell."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Row/Column Grid:"})," The grid consists of a single row or a single column."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"algorithmic-solutions",children:"Algorithmic Solutions"}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-programming",children:"Dynamic Programming"}),"\n",(0,r.jsxs)(n.p,{children:["One effective way to solve this problem is through dynamic programming. The idea is to build a 2D DP table where ",(0,r.jsx)(n.code,{children:"dp[i][j]"})," represents the minimum path sum to reach ",(0,r.jsx)(n.code,{children:"(i, j)"})," from the top-left corner."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    # Initialize first column and first row\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[j][0] = dp[0][j-1] + grid[0][j]\n\n    # Populate the DP table\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n\n    return dp[m-1][n-1]\n"})}),"\n",(0,r.jsx)(n.h4,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(m*n), where ",(0,r.jsx)(n.code,{children:"m"})," is the number of rows and ",(0,r.jsx)(n.code,{children:"n"})," is the number of columns in the grid. We traverse the entire grid once."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(m*n) for the DP table. However, this can be optimized to O(n) if we use a single row for DP and iterate through it for each row of the grid."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"space-optimized-dynamic-programming",children:"Space Optimized Dynamic Programming"}),"\n",(0,r.jsx)(n.p,{children:"We can optimize the space complexity of the previous solution by using a single-dimensional array."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    dp = [0] * n\n    dp[0] = grid[0][0]\n\n    # Initialize the first row\n    for j in range(1, n):\n        dp[j] = dp[j-1] + grid[0][j]\n\n    # Update dp for each row\n    for i in range(1, m):\n        dp[0] += grid[i][0]\n        for j in range(1, n):\n            dp[j] = min(dp[j-1], dp[j]) + grid[i][j]\n\n    return dp[-1]\n"})}),"\n",(0,r.jsx)(n.h4,{id:"complexity-analysis-1",children:"Complexity Analysis"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(m*n), similar to the previous solution."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(n), where n is the number of columns in the grid, significantly reducing the space used compared to the first approach."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"in-place-dynamic-programming",children:"In-Place Dynamic Programming"}),"\n",(0,r.jsx)(n.p,{children:"This in-place solution follows the same logic as the dynamic programming approach but avoids the use of extra space for a DP table. It directly updates the grid with the minimum path sums as it iterates through it."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[0][j - 1]\n                elif j == 0:\n                    grid[i][j] += grid[i - 1][0]\n                else:\n                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n        return grid[-1][-1]]\n"})}),"\n",(0,r.jsx)(n.h4,{id:"complexity-analysis-2",children:"Complexity Analysis"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(m*n), where ",(0,r.jsx)(n.code,{children:"m"})," is the number of rows and ",(0,r.jsx)(n.code,{children:"n"})," is the number of columns in the grid. This complexity arises because we need to traverse the entire grid once to compute the minimum path sum."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(1), excluding the input grid. This solution modifies the input grid in-place and does not require additional space proportional to the grid's size."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:'The "Minimum Path Sum" problem is a perfect example to showcase dynamic programming\'s power in solving optimization problems. Starting with a dynamic programming solutions, we further optimized the space complexity, demonstrating how incremental improvements can lead to more efficient solutions. Remember, understanding the problem and systematically breaking it down into manageable parts is key to solving complex algorithmic challenges.'}),"\n",(0,r.jsx)(n.p,{children:"By reusing the input grid to store our dynamic programming state, we manage to reduce our solution's space complexity to O(1), making it more space-efficient without compromising on the time complexity."}),"\n",(0,r.jsx)(n.p,{children:"Optimizing for space is particularly useful in scenarios where memory is a constraint, and it demonstrates a deeper understanding of dynamic programming and in-place algorithms."})]})}function c(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>o});var r=i(7294);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);