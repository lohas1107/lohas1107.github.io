"use strict";(self.webpackChunk_2_ndbrain=self.webpackChunk_2_ndbrain||[]).push([[8019],{438:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=i(5893),r=i(1151);const s={},d="153. Find Minimum in Rotated Sorted Array",l={id:"leetcode/find-minimum-in-rotated-sorted-array",title:"153. Find Minimum in Rotated Sorted Array",description:"Approach",source:"@site/docs/leetcode/0153-find-minimum-in-rotated-sorted-array.md",sourceDirName:"leetcode",slug:"/leetcode/find-minimum-in-rotated-sorted-array",permalink:"/docs/leetcode/find-minimum-in-rotated-sorted-array",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:153,frontMatter:{},sidebar:"leetcodeSidebar",previous:{title:"136. Single Number",permalink:"/docs/leetcode/single-number"},next:{title:"160. Intersection of Two Linked Lists",permalink:"/docs/leetcode/intersection-of-two-linked-lists"}},o={},c=[{value:"Approach",id:"approach",level:2},{value:"Binary Search",id:"binary-search",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"153-find-minimum-in-rotated-sorted-array",children:"153. Find Minimum in Rotated Sorted Array"}),"\n",(0,t.jsx)(n.h2,{id:"approach",children:"Approach"}),"\n",(0,t.jsx)(n.p,{children:"To find the minimum element in a rotated sorted array, we can use a binary search approach.\nThe key insight here is that if we split the rotated array into two halves, at least one of them will always be sorted.\nWe can then focus our search on the unsorted half where the minimum element must reside."}),"\n",(0,t.jsx)(n.p,{children:"Let's illustrate this approach with an example: [4,5,6,7,0,1,2]"}),"\n",(0,t.jsx)(n.h3,{id:"binary-search",children:"Binary Search"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initialize Pointers:"})," Set ",(0,t.jsx)(n.code,{children:"left"})," to the beginning of the array (",(0,t.jsx)(n.code,{children:"0"}),") and ",(0,t.jsx)(n.code,{children:"right"})," to the end (",(0,t.jsx)(n.code,{children:"6"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Binary Search:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Calculate the middle index: ",(0,t.jsx)(n.code,{children:"mid = (left + right) // 2"}),", where ",(0,t.jsx)(n.code,{children:"mid = 3"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Compare the element at ",(0,t.jsx)(n.code,{children:"mid"})," with the elements at ",(0,t.jsx)(n.code,{children:"left"})," and ",(0,t.jsx)(n.code,{children:"right"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Since ",(0,t.jsx)(n.code,{children:"nums[mid] > nums[right]"}),", the unsorted part is on the right side. We update ",(0,t.jsx)(n.code,{children:"left = mid + 1"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Repeat Binary Search:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Calculate the new ",(0,t.jsx)(n.code,{children:"mid"}),": ",(0,t.jsx)(n.code,{children:"mid = (left + right) // 2"}),", where ",(0,t.jsx)(n.code,{children:"mid = 5"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Compare ",(0,t.jsx)(n.code,{children:"nums[mid]"})," with ",(0,t.jsx)(n.code,{children:"nums[right]"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Now, ",(0,t.jsx)(n.code,{children:"nums[mid] < nums[right]"}),", so the unsorted part is on the left side. We update ",(0,t.jsx)(n.code,{children:"right = mid"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Final Step:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The final value of ",(0,t.jsx)(n.code,{children:"nums[left]"})," or ",(0,t.jsx)(n.code,{children:"nums[right]"})," is the minimum element."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def findMin(self, nums: List[int]) -> int:\n\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = (left + right) // 2\n\n            if nums[mid] > nums[right]:\n                # Unsorted part is on the right\n                left = mid + 1\n            else:\n                # Unsorted part is on the left (including mid)\n                right = mid\n\n        # The final value of nums[left] or nums[right] is the minimum element\n        return nums[left]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(log N) - Binary search is used to find the minimum element."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(1) - Constant space is used."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>d});var t=i(7294);const r={},s=t.createContext(r);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);